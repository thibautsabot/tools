<!doctype html>
<html lang="en" dir="ltr">
<head>
<title>Lighthouse performance</title>
<meta charset="utf-8">




</head>
<body>
<h2>http://xxxxx</h2><table border='1'><tr><th>Title</th><th>Score</th><th>rawValue</th><th>displayValue (last entry)</th><th>Description</th></tr><tr><td>First Contentful Paint</td><td>0.86</td><td>2559.374</td><td>2.6 s</td><td>First Contentful Paint marks the time at which the first text or image is painted. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint).</td></tr><tr><td>First Meaningful Paint</td><td>0</td><td>141613.97</td><td>141.6 s</td><td>First Meaningful Paint measures when the primary content of a page is visible. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint).</td></tr><tr><td>Speed Index</td><td>0</td><td>38696.01165498999</td><td>38.7 s</td><td>Speed Index shows how quickly the contents of a page are visibly populated. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/speed-index).</td></tr><tr><td>Screenshot Thumbnails</td><td>NaN</td><td>NaN</td><td>undefined</td><td>This is what the load of your site looked like.</td></tr><tr><td>Final Screenshot</td><td>NaN</td><td>NaN</td><td>undefined</td><td>The last screenshot captured of the pageload.</td></tr><tr><td>Estimated Input Latency</td><td>0</td><td>2787.199999999977</td><td>2,790 ms</td><td>The score above is an estimate of how long your app takes to respond to user input, in milliseconds, during the busiest 5s window of page load. If your latency is higher than 50 ms, users may perceive your app as laggy. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/estimated-input-latency).</td></tr><tr><td>Server response times are low (TTFB)</td><td>1</td><td>146.583</td><td>Root document took 150 ms</td><td>Time To First Byte identifies the time at which your server sends a response. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/ttfb).</td></tr><tr><td>First CPU Idle</td><td>0</td><td>146170.96999999997</td><td>146.2 s</td><td>First CPU Idle marks the first time at which the page's main thread is quiet enough to handle input. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/first-interactive).</td></tr><tr><td>Time to Interactive</td><td>0</td><td>146275.96999999997</td><td>146.3 s</td><td>Interactive marks the time at which the page is fully interactive. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/consistently-interactive).</td></tr><tr><td>User Timing marks and measures</td><td>NaN</td><td>NaN</td><td>undefined</td><td>Consider instrumenting your app with the User Timing API to measure your app's real-world performance during key user experiences. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/user-timing).</td></tr><tr><td>Minimize Critical Requests Depth</td><td>NaN</td><td>NaN</td><td>5 chains found</td><td>The Critical Request Chains below show you what resources are loaded with a high priority. Consider reducing the length of chains, reducing the download size of resources, or deferring the download of unnecessary resources to improve page load. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/critical-request-chains).</td></tr><tr><td>Avoid multiple page redirects</td><td>1</td><td>0</td><td></td><td>Redirects introduce additional delays before the page can be loaded. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/redirects).</td></tr><tr><td>Minimize main-thread work</td><td>0</td><td>17412.324000000102</td><td>17.4 s</td><td>Consider reducing the time spent parsing, compiling and executing JS. You may find delivering smaller JS payloads helps with this.</td></tr><tr><td>Reduce JavaScript execution time</td><td>0.07</td><td>11447.475999999995</td><td>11.4 s</td><td>Consider reducing the time spent parsing, compiling, and executing JS. You may find delivering smaller JS payloads helps with this. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/bootup).</td></tr><tr><td>Preload key requests</td><td>1</td><td>0</td><td></td><td>Consider using <link rel=preload> to prioritize fetching resources that are currently requested later in page load. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/preload).</td></tr><tr><td>Preconnect to required origins</td><td>0.87</td><td>152.807</td><td>Potential savings of 150 ms</td><td>Consider adding preconnect or dns-prefetch resource hints to establish early connections to important third-party origins. [Learn more](https://developers.google.com/web/fundamentals/performance/resource-prioritization#preconnect).</td></tr><tr><td>All text remains visible during webfont loads</td><td>1</td><td>NaN</td><td>undefined</td><td>Leverage the font-display CSS feature to ensure text is user-visible while webfonts are loading. [Learn more](https://developers.google.com/web/updates/2016/02/font-display).</td></tr><tr><td>Network Requests</td><td>NaN</td><td>39</td><td>undefined</td><td>Lists the network requests that were made during page load.</td></tr><tr><td>Metrics</td><td>NaN</td><td>146275.96999999997</td><td>undefined</td><td>Collects all available metrics.</td></tr><tr><td>Serve static assets with an efficient cache policy</td><td>0</td><td>28096178.258519553</td><td>29 resources found</td><td>A long cache lifetime can speed up repeat visits to your page. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/cache-policy).</td></tr><tr><td>Avoid enormous network payloads</td><td>0</td><td>28413884</td><td>Total size was 27,748 KB</td><td>Large network payloads cost users real money and are highly correlated with long load times. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/network-payloads).</td></tr><tr><td>Defer offscreen images</td><td>1</td><td>0</td><td></td><td>Consider lazy-loading offscreen and hidden images after all critical resources have finished loading to lower time to interactive. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/offscreen-images).</td></tr><tr><td>Eliminate render-blocking resources</td><td>0.58</td><td>606</td><td>Potential savings of 610 ms</td><td>Resources are blocking the first paint of your page. Consider delivering critical JS/CSS inline and deferring all non-critical JS/styles. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/blocking-resources).</td></tr><tr><td>Minify CSS</td><td>1</td><td>0</td><td>Potential savings of 39 KB</td><td>Minifying CSS files can reduce network payload sizes. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/minify-css).</td></tr><tr><td>Minify JavaScript</td><td>0</td><td>98700</td><td>Potential savings of 19,734 KB</td><td>Minifying JavaScript files can reduce payload sizes and script parse time. [Learn more](https://developers.google.com/speed/docs/insights/MinifyResources).</td></tr><tr><td>Defer unused CSS</td><td>1</td><td>0</td><td>Potential savings of 275 KB</td><td>Remove unused rules from stylesheets to reduce unnecessary bytes consumed by network activity. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/unused-css).</td></tr><tr><td>Serve images in next-gen formats</td><td>1</td><td>0</td><td>Potential savings of 30 KB</td><td>Image formats like JPEG 2000, JPEG XR, and WebP often provide better compression than PNG or JPEG, which means faster downloads and less data consumption. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/webp).</td></tr><tr><td>Efficiently encode images</td><td>1</td><td>0</td><td></td><td>Optimized images load faster and consume less cellular data. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/optimize-images).</td></tr><tr><td>Enable text compression</td><td>0</td><td>110910</td><td>Potential savings of 22,218 KB</td><td>Text-based resources should be served with compression (gzip, deflate or brotli) to minimize total network bytes. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/text-compression).</td></tr><tr><td>Properly size images</td><td>1</td><td>0</td><td>Potential savings of 6 KB</td><td>Serve images that are appropriately-sized to save cellular data and improve load time. [Learn more](https://developers.google.com/web/tools/lighthouse/audits/oversized-images).</td></tr><tr><td>Use video formats for animated content</td><td>1</td><td>0</td><td></td><td>Large GIFs are inefficient for delivering animated content. Consider using MPEG4/WebM videos for animations and PNG/WebP for static images instead of GIF to save network bytes. [Learn more](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/)</td></tr><tr><td>Avoid an excessive DOM size</td><td>0</td><td>11714</td><td>11,714 nodes</td><td>Browser engineers recommend pages contain fewer than ~1,500 DOM nodes. The sweet spot is a tree depth < 32 elements and fewer than 60 children/parent element. A large DOM can increase memory usage, cause longer [style calculations](https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations), and produce costly [layout reflows](https://developers.google.com/speed/articles/reflow). [Learn more](https://developers.google.com/web/tools/lighthouse/audits/dom-size).</td></tr></table>

</body>
</html>
